---
title: "workflow"
output: html_document
editor_options: 
  chunk_output_type: console
---


## Repeated measures data from a RNA sequencing experiment


```{r}

library(seqwrap)

# Load example data
dat <- data.frame(seqwrap::rna_seq_sample)

metdat <- seqwrap::rna_seq_metadata

metdat <- metdat[metdat$rnaseq_include == "incl",]

# Calculate the "library size" for each sample


# Convert to integer data
dat <- cbind(dat[,1], data.frame(lapply(dat[,-1], function(x) as.integer(round(x)))))

# Calculate the library size
libsize <- colSums(dat[,-1])

libsize <- data.frame(
  seq_sample_id = colnames(dat)[-1],
  libsize = log(libsize), 
  row.names = NULL
)


# Combine the library size with the metadata
metdat_comb <- merge(metdat, libsize, by = "seq_sample_id")

# Change levels in the time factor
metdat_comb$time <- factor(metdat_comb$time, levels = c("w0", "w2pre", "w2post", "w12"))

metdat <- metdat_comb

```


### Prepare summary and evaluation functions


```{r}
# Data and meta data for a single model 


testdat <- metdat_comb
testdat$y <- as.numeric(dat[2,-1 ])


# Running a single model 
m <- glmmTMB::glmmTMB(
  y ~ time + time:condition + (1|participant) + offset(libsize),
  data = testdat,
  family = glmmTMB::nbinom1()
)



# The summary function should retreive the model summary
sumfun <- function(m) {
  
  cond_effects <- data.frame(coef(summary(m))$cond)
  cond_effects$coef <- rownames(cond_effects)
  rownames(cond_effects) <- NULL
  
  # For calculating the df
  n_fix <- nrow(coef(summary(m))$cond)
  n_ran <- m$modelInfo$reStruc$condReStruc[[1]]$blockReps
  n_obs <- nobs(m)
  
  df <- n_obs - n_fix - n_ran
  
  
  colnames(cond_effects)[1:4] <- c("estimate", "se", "zval", "pval")
  cond_effects <- cond_effects[,c(5,1:4)]
  
  # Extract fitted mean values
  gene_mean <- mean(fitted(m))
  
  ## Get the dispersion parameter
  results <- rbind(cond_effects, 
                   data.frame(coef = c("dispersion","gene_mean", "variance", "df"), 
                              estimate = c(summary(m)$sigma,
                                           gene_mean, 
                                           gene_mean * (1 + gene_mean/summary(m)$sigma), 
                                           df),
                              
                              se = NA, 
                              zval = NA, 
                              pval = NA)
  )
  return(results)
             
}





evalfun <- function(m) {
  
  
 # resids <- DHARMa::simulateResiduals(m, n = 1000)
  
 # uniformity <- DHARMa::testUniformity(resids, plot = FALSE)
  
  results <- data.frame(uniform.p = NA)
  return(results)
}




sumfun(m)

evalfun(m)



```




### Prepare the data for seqwrap: `seqwrap_compose()`


```{r}



dat <- dat[1:100,]




swdat <- seqwrap_compose(
  data = dat,
  metadata = metdat_comb,
  samplename = "seq_sample_id",
  modelfun = glmmTMB::glmmTMB,
  summary_fun = sumfun,
  eval_fun = evalfun,
  targetdata = NULL,
#  additional_vars =  "libsize",
  arguments = list(formula = y ~ time + time:condition + 
                     (1|participant) + offset(libsize),
                   family = glmmTMB::nbinom2()),
  

)


models <- seqwrap(swdat)



```


#### Combine results


```{r}

summaries <- seqwrap_summarise(models)

# Summary results
cond_effects <- summaries$summaries


dispersion_vals_log <- log(cond_effects[cond_effects$coef == "dispersion",]$estimate)
dispersion_vals <- cond_effects[cond_effects$coef == "dispersion",]$estimate
gene_means <- log(cond_effects[cond_effects$coef == "gene_mean",]$estimate)
df <- cond_effects[cond_effects$coef == "df",]$estimate



trendfit <- loess(dispersion_vals_log ~ gene_means, span = 0.75)

trenddisp <- exp(predict(trendfit, 
                         newdata = data.frame(gene_means = gene_means)))

## Shrinkage 
prior_df <- 10
gene_df <- df


## Shrink dispersion values
dispersion_vals_shrinkage <- (dispersion_vals * gene_df + trenddisp * prior_df) /
  (gene_df + prior_df)





plot(gene_means, dispersion_vals_log)

xseq <- seq(min(gene_means), max(gene_means), length.out = 100)
y_pred <- predict(trendfit, newdata = data.frame(gene_means = xseq))

lines(xseq, y_pred, col = "red", lwd = 2)
points(gene_means, log(dispersion_vals_shrinkage), pch = 19, col = "blue")




```



#### Use shrinkage values in refitting the model

```{r}

testdat



m2 <- glmmTMB::glmmTMB(
  y ~ time + time:condition + (1|participant) + offset(libsize),
  data = testdat,
  family = glmmTMB::nbinom1(),
  map = list(betad = factor(NA)),
  start = list(betad = log(14))
)



sumfun(m2)
evalfun(m2)







```



```{r}

# Some models where not fitted correctly and do not have corresponding 
# dispersion estimates. Retain only the models that were fitted correctly

dat <- dat[dat[, 1] %in% unique(cond_effects$target),]


# Sort the data in order of the dispersion values
dat2 <- dat[order(match(dat[,1], cond_effects[cond_effects$coef == "dispersion",]$target)),]


dispersions <- data.frame(trenddisp = log(dispersion_vals_shrinkage)[1:10])



swdat2 <- seqwrap_compose(
  data = dat2[1:10,],
  metadata = metdat_comb,
  samplename = "seq_sample_id",
  modelfun = glmmTMB::glmmTMB,
  summary_fun = sumfun,
  eval_fun = evalfun,
  targetdata = dispersions,
  additional_vars =  NULL,
  arguments = list(formula = y ~ time + time:condition + 
                     (1|participant) + offset(libsize),
                   map = list(betad = factor(NA)),
                   start = alist(betad = trenddisp),
                   family = glmmTMB::nbinom1()),
  
)


models2 <- seqwrap(swdat2, return_models = TRUE)  



sumfun(models2@models[[1]])

sums <- seqwrap_summarise(models)

sums <- sums$summaries


old_disp <- cond_effects[cond_effects$coef == "dispersion", c("target","estimate") ]
colnames(old_disp) <- c("target", "old_dispersion")

new_disp <- sums[sums$coef == "dispersion", c("target","estimate") ]

comb <- merge(old_disp, new_disp, by = "target")


plot(comb$old_dispersion, comb$estimate)


models2@errors[1,2][[1]]

```




## EdgeR and seqwrap comparison

```{r}

library(edgeR)


fname <- "http://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE49712&format=file&file=GSE49712_HTSeq.txt.gz"
download.file(fname, destfile = "GSE49712_HTSeq.txt.gz")

data_raw <- read.table("GSE49712_HTSeq.txt.gz", header = TRUE)

d <- data.frame(targets = rownames(data_raw), 
                data_raw[,1:ncol(data_raw)], 
                row.names = NULL)

# Remove five lines with summarises
d <- d[1:(nrow(d)-5),]




```



```{r}


## Filter low expressed targets
cpm_log <- cpm(d[,-1], log = TRUE)
median_log2_cpm <- apply(cpm_log, 1, median)
expr_cutoff <- 0

d <- d[median_log2_cpm > expr_cutoff, ]






md <- data.frame(seq_id = colnames(d)[-1], 
                 group = rep(c("A", "B"), each = 5), 
                 libsize = log(as.numeric(colSums(d[,-1]))))



testdat <- data.frame(y = as.numeric(d[1,-1]), 
                      group = factor(md$group),
                      libsize = md$libsize, 
                      row.names = NULL)

m <- MASS::glm.nb(y ~ group + offset(libsize), 
                  
           data = testdat)
summary(m)

sumfun <- function(m) {
  
  # Main effects 
  cond_effects <- data.frame(coef(summary(m)))
  cond_effects$coef <- rownames(cond_effects)  
  rownames(cond_effects) <- NULL  
  cond_effects <- cond_effects[,c(5,1:4)]  
  colnames(cond_effects)[1:5] <- c("coef","estimate", "se", "zval", "pval")
  
  # Dispersion
  dispersion <- data.frame(coef = "dispersion", 
                           estimate = m$theta, 
                           se = NA, 
                           zval = NA, 
                           pval = NA)
  # Gene mean
  gene_mean <- data.frame(coef = "gene_mean", 
                           estimate = mean(fitted(m)), 
                           se = NA, 
                           zval = NA, 
                           pval = NA)
  
  # Gene df
  df <- data.frame(coef = "df", 
                           estimate = m$df.residual, 
                           se = NA, 
                           zval = NA, 
                           pval = NA)

  ## Combine the output
  out <- rbind(cond_effects, dispersion, gene_mean, df)
  
  return(out)  
  
}


evalfun <- function(m) {
  
  return(data.frame(some_criteria = NA))
  
}




swd <- seqwrap_compose(modelfun = MASS::glm.nb, 
                       data = d, 
                       metadata = md, 
                       samplename = "seq_id",
                       summary_fun = sumfun,
                       eval_fun = evalfun,
                         additional_vars =  NULL,
                       arguments = alist(formula = y ~ group + offset(libsize), 
                                         maxit = 500))


prel_models <- seqwrap(swd, return_models = FALSE, cores = 12)                      

# prel_models@errors[10,2][[1]]



## Extract dispersions

prel_summaries <- seqwrap_summarise(prel_models)
prel_summaries <- prel_summaries$summaries

dispersions <- data.frame(target = prel_summaries[prel_summaries$coef == "dispersion","target"], 
           dispersion = prel_summaries[prel_summaries$coef == "dispersion","estimate"], 
           gene_mean = prel_summaries[prel_summaries$coef == "gene_mean","estimate"], 
           df = prel_summaries[prel_summaries$coef == "df","estimate"])
                       
 
dmerge <- merge(d, dispersions, by.x = "targets", by.y = "target")

dmerge$m <- rowMeans(dmerge[,2:7])
plot(dmerge$m, log(dmerge$dispersion))

## Shrink dispersion values
disp <- dispersions$dispersion
avg_mean <- log(dispersions$gene_mean)

# Fit loess
loess_fit <- loess(log(disp) ~ avg_mean, span = 0.5)

# Predict loess
xseq <- seq(min(avg_mean), max(avg_mean), length.out = 100)
prior_disp <- exp(predict(loess_fit, newdata = data.frame(avg_mean = avg_mean)))
# The trend for plotting
trend <- predict(loess_fit, newdata = data.frame(avg_mean = xseq))



## Calculate shrinkage
prior_df <- 3
gene_df <- 3 # Same as residuial DF in models

shrink_disp <- (gene_df * disp + prior_df * prior_disp)/ (gene_df + prior_df)

plot(avg_mean, log(disp))
lines(xseq, trend, col = "red", lwd = 2)
points(avg_mean, log(shrink_disp), pch = 19, col = "blue")





## Re-fit the model with dispersion values after shrinkage


testdat <- data.frame(y = as.numeric(d[1,-1]), 
                      group = md$group, 
                      libsize = log(md$libsize), 
                      row.names = NULL)

m <- stats::glm(y ~ group + offset(libsize), 
                family = MASS::negative.binomial(theta = 53),
           data = testdat)
summary(m)

sumfun2 <- function(m) {
  
  # Main effects 
  cond_effects <- data.frame(coef(summary(m)))
  cond_effects$coef <- rownames(cond_effects)  
  rownames(cond_effects) <- NULL  
  cond_effects <- cond_effects[,c(5,1:4)]  
  colnames(cond_effects)[1:5] <- c("coef","estimate", "se", "zval", "pval")
  

 
  gene_mean <- data.frame(coef = "gene_mean", 
                           estimate = mean(fitted(m)), 
                           se = NA, 
                           zval = NA, 
                           pval = NA)
  
  # Gene df
  df <- data.frame(coef = "df", 
                   estimate = m$df.residual, 
                   se = NA, 
                   zval = NA, 
                   pval = NA)

  ## Combine the output
  out <- rbind(cond_effects, gene_mean, df)
  
  return(out)  
  
}


# Some genes were not fitted correctly and do not have corresponding
# dispersion estimates. Retain only the models that were fitted correctly

d2 <- d[d[, 1] %in% unique(dispersions$target),]
d2 <- d2[order(match(d2[,1], dispersions$target)),]


# Check that the data is sorted
all(d2[,1] == dispersions$target)

# Extract dipersions into a data frame
disp_vals <- data.frame(disp = dispersions$dispersion)


swd2 <- seqwrap_compose(modelfun = stats::glm, 
                       data = d2,
                       metadata = md, 
                       samplename = "seq_id",
                       summary_fun = sumfun2,
                       eval_fun = evalfun,
                       targetdata = disp_vals,
                       additional_vars =  NULL,
                       arguments = alist(formula = y ~ group + offset(libsize),
                                        family = MASS::negative.binomial(theta = disp))) 


models2 <- seqwrap(swd2, return_models = FALSE, cores = 12)

sum2 <- seqwrap_summarise(models2)$summaries


sums <- data.frame(target = sum2[sum2$coef == "groupB",]$target, 
                   estimate = sum2[sum2$coef == "groupB",]$estimate,
                   se = sum2[sum2$coef == "groupB",]$se,
                   pval = sum2[sum2$coef == "groupB",]$pval, 
                   avg_mean = sum2[sum2$coef == "gene_mean",]$estimate)


plot(sums$avg_mean, sums$estimate)


                  
```











