---
title: "Flexible iterative fitting over omics-type data using the modeling algorithm of your choice"
output: rmarkdown::html_vignette
bibliography: references.bib
author: "Daniel HammarstrÃ¶m"
date: "2025-04-07"
vignette: >
  %\VignetteIndexEntry{seqwrap-workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(seqwrap)
```



## Background

Differential expression is determined in RNA-sequencing experiments using specific software packages such as edgeR REF:McCarthy2012 or DEseq2 REF:Love2014. These packages provides efficient algorithms for fitting gene-expression data to count-based models by sharing information across genes in relatively simple designs. More elaborate experimental designs may require the addition of random effects to such models when observations are not independent. To accommodate random effects Vestal et al. REF:vestal2022 developed [lmerSeq](https://github.com/stop-pre16/lmerSeq) which allowed iterative fitting of mixed linear models to transformed count data. Similarly, Lewis et al. [@Lewis] developed [glmmSeq](https://cran.r-project.org/web/packages/glmmSeq/vignettes/glmmSeq.html#glmmSeq) to fit negative binomial mixed effects models. We have previously used negative binomial mixed models to fit data from repeated measures designs [@Khan2020; @Mlmen2021], however the software implementation was not formalized to user-friendly functions.

The aim of the `seqwrap` package is to provide even more flexibility to model fitting of omics-type data. Although [lmerSeq](https://github.com/stop-pre16/lmerSeq) and [glmmSeq](https://cran.r-project.org/web/packages/glmmSeq/vignettes/glmmSeq.html#glmmSeq) both provides powerful implementations of fitting algorithms to iterative fitting they are limited as the user cannot select which fitting algorithm to use. `seqwrap` can use any available fitting algorithm (`stats::lm`, `glmmTMB::glmmTMB`, `lme4::lmer`, etc.) which makes the model fitting process more flexible. In addition, the user can provide user-created summary- and model evaluation-functions to tailor output for specific purposes.

## Iterative fitting of high dimensional data

The `seqwrap` function lets the user specify which modelling algorithm to be used when modelling data provided as a data frame and metadata describing each sample. Target-specific models are passed to the results together with optional user-specified summary and model-evaluation functions. The function aims to not limit the user in preferences of specific models. This allows for comparisons between modelling frameworks and flexibility for many types of omics-type data. The basic workflow is described below.


### Fitting count data to a negative binomial model using `glmmTBM`

We will start by simulating data from a simple experiment where count data has been gathered from 25 clusters in two conditions (e.g. treatment and control). 

```{r}
#| label: fig-simulated-data

library(seqwrap)
library(glmmTMB)
library(DHARMa)


# Simulate data
dat <- seqwrap:::simcounts(n_genes = 1000, 
                    n_samples = 50, 
                    beta_0 = 2, 
                    sigma_0 = 0.5, 
                    beta_1 = 0.5,, 
                    sigma_1 = 2, 
                    b_0 = 1,
                    clusters = 25,
                    overdispersion_min =c(1, 10))

# Calculate library sizes
dat$metadata$libsize <- log(colSums(dat$data[, -1]) )


```

Using `seqwrap_compose` we can populate a `swcontainer` object with all needed information to fit models. The `swcontainer` objects is basically a list with data, meta data and arguments that goes into the model algorithm. The `swcontainer` object also contain the desired modelfunction. 

```{r}

swobject <- seqwrap_compose(
  data = dat$data, # A data frame with the first column as the target identifier
  metadata = dat$metadata, # Meta data bout samples, containing predictors
  samplename = "sample", # The name sample id column 
  modelfun = glmmTMB::glmmTMB, # The model fitting function
  # A list of argumnets supplied to the modelfunction
  arguments = list(
    formula = y ~ x + (1 | cluster),
    family = glmmTMB::nbinom1
  ),
  summary_fun = NULL,
  eval_fun = NULL,
  additional_vars = NULL
)

```


We might want to add functions that summarise and evaluate the fitted model. Below we spefify two functions for these purposes. 

```{r}

sumfun <- function(x) {
  # A function that returns a data frame with the coefficients
  # from the fitted model
  cond_effects <- data.frame(
    cbind(
      data.frame(
        coef = rownames(coef(summary(x))$cond)
      )
    ),
    coef(summary(x))$cond,
    row.names = NULL
  )

  return(cond_effects)
}


evalfun <- function(x) {
  # A function that returns a data frame with the p-values from
  # the residual diagnostics
  sim <- DHARMa::simulateResiduals(x, n = 1000)
  unif <- DHARMa::testUniformity(sim, plot = FALSE)
  results <- data.frame(
    pval.unif = unif$p.value,
  )

  return(results)
}





```


The `seqwrap` function will iterate over all targets in the data and fit the model and apply the summary and evaluation function to each model. Notice that we can use `return_models = TRUE` to save model in the output. Below we also use `subset = 1:10` to only do the first 10 targets. This is useful when we want to check if teh summary and evaluation functions work as intended. The `swobject` created above is updated when we supply ne w arguments to `seqwrap`.


```{r}

models <- seqwrap(swobject, 
                  summary_fun = sumfun,
                  eval_fun = evalfun,
                  return_models = TRUE,
                  subset = 1:10) 

```

As evident from the output we have 10 errors in the Evaluation function. Let's re-examine the evaluation function. 

```{r}

# Getting 1 model for testing from preliminary models
x <- models@models[[1]]

evalfun(x)

```

It turns out that a simple typo in the evaluation function caused the error. We can access the error message, or what `seqwrap` have managed to save e.g. using: 

```{r}
models@errors[1,6][[1]]
```

This might be needed when debugging the model fitting process or summary/evaluation functions.

Let's update the evaluation function and start fitting the models. We will increase the number of cores to speed up the process. Here we will not save the models to save space. 

```{r}

evalfun2 <- function(x) {
  # A function that returns a data frame with the p-values from
  # the residual diagnostics
  sim <- DHARMa::simulateResiduals(x, n = 1000)
  unif <- DHARMa::testUniformity(sim, plot = FALSE)
  results <- data.frame(
    pval.unif = unif$p.value
  )
  
}
  

models_final <- seqwrap(swobject, 
                  summary_fun = sumfun,
                  eval_fun = evalfun2,
                  return_models = FALSE, 
                  cores = 10)



```

The summary of the modelling process indicates that some targets where not included in the summaries, presumably the same targets that had warnings in `glmmTMB::glmmTMB`.


The models can be conveniently summarised using the `seqwrap_summarise` function.

```{r}


summaries <- seqwrap_summarise(models_final)

head(summaries$summaries)

head(summaries$evaluations)



```
















## References
